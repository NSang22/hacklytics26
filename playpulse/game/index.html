<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PlayPulse Demo Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #111; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: sans-serif; color: #fff; }
    #hud { width: 800px; display: flex; justify-content: space-between; padding: 6px 0; font-size: 14px; }
    canvas { border: 2px solid #444; display: block; }
    #presage-container { width: 200px; height: 150px; border: 1px dashed #555; position: fixed; top: 10px; right: 10px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #888; }
  </style>
</head>
<body>

<div id="hud">
  <span id="hud-room">Room: tutorial</span>
  <span id="hud-deaths">Deaths: 0</span>
  <span id="hud-time">Time: 0s</span>
</div>
<canvas id="game" width="800" height="600"></canvas>

<!-- Presage SDK webcam placeholder -->
<div id="presage-container">Presage webcam<br/>(placeholder)</div>

<script>
// â”€â”€â”€ PlayPulse SDK (inline for zero-dep single-file game) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class PlayPulseSDK {
  constructor(sessionId, apiKey, endpoint) {
    this.sessionId = sessionId;
    this.apiKey = apiKey;
    this.startTime = Date.now();
    this.queue = [];
    this.connected = false;
    this.endpoint = endpoint || 'ws://localhost:8000/v1/stream';
    this.ws = new WebSocket(
      `${this.endpoint}?session_id=${encodeURIComponent(sessionId)}&api_key=${encodeURIComponent(apiKey)}`
    );
    this.ws.onopen = () => {
      this.connected = true;
      this.send('session_start', 'connected');
      this.queue.forEach(m => this.ws.send(JSON.stringify(m)));
      this.queue = [];
    };
    this.ws.onerror = e => console.error('[PlayPulse] WS error', e);
    this.ws.onclose = () => { this.connected = false; };
  }
  _ts() { return (Date.now() - this.startTime) / 1000; }
  send(eventType, eventName, payload = {}) {
    const msg = { session_id: this.sessionId, event_type: eventType, event_name: eventName, timestamp: this._ts(), payload };
    this.connected ? this.ws.send(JSON.stringify(msg)) : this.queue.push(msg);
  }
  gameEvent(n, p={})    { this.send('game_event', n, p); }
  playerAction(n, p={}) { this.send('player_action', n, p); }
  stateChange(n, p={})  { this.send('state_change', n, p); }
  milestone(n, p={})    { this.send('milestone', n, p); }
  metric(n, p={})       { this.send('metric', n, p); }
  endSession(p={})      { this.send('session_end','complete',{...p, total_time_sec:this._ts()}); setTimeout(()=>this.ws.close(),500); }
}

// â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const params = new URLSearchParams(window.location.search);
const SESSION_ID = params.get('session_id') || 'demo-' + Math.random().toString(36).slice(2, 8);
const API_KEY    = params.get('api_key') || 'dev';
const WS_URL     = params.get('ws') || 'ws://localhost:8000/v1/stream';

const pp = new PlayPulseSDK(SESSION_ID, API_KEY, WS_URL);

// â”€â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// â”€â”€â”€ Room definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each room is a colored rectangle region placed left-to-right in a wide world.
// Room x-ranges in world coordinates:

const ROOMS = [
  { name: 'tutorial',  x: 0,    w: 800,  color: '#1a3a1a', label: 'Tutorial',       intended: 'calm'      },
  { name: 'puzzle',    x: 800,  w: 800,  color: '#1a1a3a', label: 'Puzzle Room',    intended: 'curious'   },
  { name: 'surprise',  x: 1600, w: 400,  color: '#3a1a1a', label: 'Surprise Event', intended: 'surprise'  },
  { name: 'gauntlet',  x: 2000, w: 1000, color: '#3a2a0a', label: 'Gauntlet',       intended: 'tense'     },
  { name: 'victory',   x: 3000, w: 600,  color: '#0a3a2a', label: 'Victory!',       intended: 'satisfied' },
];

const WORLD_W = 3600;

// â”€â”€â”€ Player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const player = {
  x: 60, y: H / 2,
  w: 24, h: 24,
  speed: 4,
  color: '#4fc3f7',
};

let deaths = 0;
let currentRoom = 'tutorial';
let gameOver = false;
let startTimeSec = Date.now() / 1000;

// Camera offset (scrolls to follow player)
let cameraX = 0;

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup',   e => { keys[e.key.toLowerCase()] = false; });

function movePlayer() {
  if (gameOver) return;
  let dx = 0, dy = 0;
  if (keys['arrowleft']  || keys['a']) dx -= player.speed;
  if (keys['arrowright'] || keys['d']) dx += player.speed;
  if (keys['arrowup']    || keys['w']) dy -= player.speed;
  if (keys['arrowdown']  || keys['s']) dy += player.speed;

  player.x += dx;
  player.y += dy;

  // Clamp to world bounds
  if (player.x < 0) player.x = 0;
  if (player.x + player.w > WORLD_W) player.x = WORLD_W - player.w;
  if (player.y < 0) player.y = 0;
  if (player.y + player.h > H) player.y = H - player.h;

  if (dx !== 0 || dy !== 0) {
    pp.playerAction('move', { dx, dy });
  }
}

// â”€â”€â”€ Obstacles (gauntlet) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const obstacles = [];
// Create some moving obstacles in the gauntlet zone
for (let i = 0; i < 6; i++) {
  obstacles.push({
    x: 2100 + i * 150,
    y: 100 + (i % 3) * 180,
    w: 30,
    h: 30,
    vy: (i % 2 === 0 ? 2 : -2),
    color: '#e53935',
  });
}

function updateObstacles() {
  for (const ob of obstacles) {
    ob.y += ob.vy;
    if (ob.y < 0 || ob.y + ob.h > H) ob.vy *= -1;
  }
}

function checkObstacleCollision() {
  if (gameOver) return;
  for (const ob of obstacles) {
    if (
      player.x < ob.x + ob.w &&
      player.x + player.w > ob.x &&
      player.y < ob.y + ob.h &&
      player.y + player.h > ob.y
    ) {
      // Death!
      deaths++;
      pp.gameEvent('player_death', { room: currentRoom, deaths });
      // Respawn at gauntlet start
      player.x = 2020;
      player.y = H / 2;
      return;
    }
  }
}

// â”€â”€â”€ Room detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function detectRoom() {
  for (const room of ROOMS) {
    if (player.x >= room.x && player.x < room.x + room.w) {
      if (room.name !== currentRoom) {
        const prev = currentRoom;
        currentRoom = room.name;
        pp.stateChange(`enter_${room.name}`, { from: prev });
        if (room.name === 'victory') {
          pp.milestone('game_complete', { deaths, time_sec: (Date.now()/1000 - startTimeSec).toFixed(1) });
          gameOver = true;
        }
      }
      return;
    }
  }
}

// â”€â”€â”€ Stuck detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let lastSignificantPos = { x: player.x, y: player.y, time: Date.now() };

function checkStuck() {
  const dist = Math.hypot(player.x - lastSignificantPos.x, player.y - lastSignificantPos.y);
  if (dist > 40) {
    lastSignificantPos = { x: player.x, y: player.y, time: Date.now() };
  } else if (Date.now() - lastSignificantPos.time > 30000 && currentRoom === 'puzzle') {
    pp.gameEvent('stuck_detected', { room: currentRoom, duration_ms: Date.now() - lastSignificantPos.time });
    lastSignificantPos.time = Date.now(); // reset so we don't spam
  }
}

// â”€â”€â”€ Metric polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setInterval(() => {
  pp.metric('player_state', {
    x: Math.round(player.x),
    y: Math.round(player.y),
    room: currentRoom,
    deaths,
  });
}, 2000);

// â”€â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function render() {
  ctx.clearRect(0, 0, W, H);

  // Camera follow
  cameraX = player.x - W / 2;
  if (cameraX < 0) cameraX = 0;
  if (cameraX > WORLD_W - W) cameraX = WORLD_W - W;

  // Draw rooms
  for (const room of ROOMS) {
    const rx = room.x - cameraX;
    ctx.fillStyle = room.color;
    ctx.fillRect(rx, 0, room.w, H);

    // Room label
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.font = 'bold 32px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(room.label, rx + room.w / 2, H / 2 - 60);
  }

  // Room divider lines
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  for (const room of ROOMS) {
    const rx = room.x - cameraX;
    ctx.beginPath();
    ctx.moveTo(rx, 0);
    ctx.lineTo(rx, H);
    ctx.stroke();
  }

  // Draw obstacles (only in gauntlet visible area)
  for (const ob of obstacles) {
    const ox = ob.x - cameraX;
    if (ox > -50 && ox < W + 50) {
      ctx.fillStyle = ob.color;
      ctx.fillRect(ox, ob.y, ob.w, ob.h);
    }
  }

  // Draw player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x - cameraX, player.y, player.w, player.h);

  // Victory overlay
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#4caf50';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸŽ‰ Victory!', W / 2, H / 2 - 20);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif';
    ctx.fillText(`Deaths: ${deaths}  |  Time: ${((Date.now()/1000 - startTimeSec)).toFixed(1)}s`, W / 2, H / 2 + 30);
  }

  // HUD
  document.getElementById('hud-room').textContent   = `Room: ${currentRoom}`;
  document.getElementById('hud-deaths').textContent  = `Deaths: ${deaths}`;
  document.getElementById('hud-time').textContent    = `Time: ${((Date.now()/1000 - startTimeSec)).toFixed(0)}s`;
}

// â”€â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function loop() {
  movePlayer();
  updateObstacles();
  checkObstacleCollision();
  detectRoom();
  checkStuck();
  render();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
