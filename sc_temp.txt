"""
Screen Capture Module ΓÇö captures the screen at configurable FPS using mss.

Supports two modes:
  ΓÇó Preview-only: grabs frames for UI thumbnail (no disk writes)
  ΓÇó Recording: additionally writes .mp4 chunk files and dispatches them

Settings (FPS, monitor, resolution) can be changed live via update_settings().
"""

from __future__ import annotations

import os
import time
import tempfile
import threading
from typing import Callable, Optional, Tuple

import cv2
import numpy as np
import mss


class ScreenCapture:
    """Captures the screen at a given FPS. Supports preview-only and recording modes."""

    def __init__(
        self,
        fps: int = 3,
        chunk_duration_sec: float = 10.0,
        monitor_index: int = 1,
        resolution: Optional[Tuple[int, int]] = None,
    ):
        self.fps = max(1, min(fps, 30))
        self.chunk_duration_sec = chunk_duration_sec
        self.monitor_index = monitor_index
        self.resolution = resolution  # (width, height) or None for native
        self._running = False
        self._recording = False
        self._thread: Optional[threading.Thread] = None
        self._chunk_index = 0
        self._on_chunk_ready: Optional[Callable[[bytes, int], None]] = None
        self._lock = threading.Lock()
        self._latest_frame: Optional[np.ndarray] = None
        self._frame_lock = threading.Lock()
        self._frame_seq: int = 0
        self._actual_fps: float = 0.0
        self._last_frame_time: float = 0.0

    # ΓöÇΓöÇ Public API ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ

    def start_preview(self) -> None:
        """Start the capture loop in preview-only mode (no chunk writing)."""
        if self._running:
            return
        self._running = True
        self._recording = False
        self._thread = threading.Thread(target=self._capture_loop, daemon=True)
        self._thread.start()

    def start(self, on_chunk_ready: Callable[[bytes, int], None]) -> None:
        """Start screen capture with chunk recording.

        If already running in preview, upgrades to recording mode.
        """
        self._on_chunk_ready = on_chunk_ready
        self._chunk_index = 0
        if self._running:
            self._recording = True
            return
        self._running = True
        self._recording = True
        self._thread = threading.Thread(target=self._capture_loop, daemon=True)
        self._thread.start()

    def stop_recording(self) -> None:
        """Stop chunk recording but keep preview running."""
        self._recording = False

    def stop(self) -> None:
        """Stop the capture loop entirely (preview + recording)."""
        self._running = False
        self._recording = False
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=5.0)
        self._thread = None

    def update_settings(
        self,
        fps: Optional[int] = None,
        monitor_index: Optional[int] = None,
        resolution=None,
    ) -> None:
        """Update capture settings live. Restarts the loop if running."""
        changed = False
        if fps is not None and fps != self.fps:
            self.fps = max(1, min(fps, 30))
            changed = True
        if monitor_index is not None and monitor_index != self.monitor_index:
            self.monitor_index = monitor_index
            changed = True
        if resolution is not None and resolution != self.resolution:
            self.resolution = resolution
            changed = True

        if changed and self._running:
            was_recording = self._recording
            cb = self._on_chunk_ready
            self.stop()
            time.sleep(0.1)
            if was_recording and cb:
                self.start(on_chunk_ready=cb)
            else:
                self.start_preview()

    @property
    def is_running(self) -> bool:
        return self._running

    @property
    def is_recording(self) -> bool:
        return self._recording

    # ΓöÇΓöÇ Internal ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ

    def _capture_loop(self) -> None:
        """Main loop ΓÇö grabs frames at target FPS; writes chunks when recording."""
        with mss.mss() as sct:
            monitor = sct.monitors[self.monitor_index]

            if self.resolution:
                out_w, out_h = self.resolution
            else:
                out_w = monitor["width"]
                out_h = monitor["height"]

            out_w = out_w if out_w % 2 == 0 else out_w - 1
            out_h = out_h if out_h % 2 == 0 else out_h - 1

            while self._running:
                frame_interval = 1.0 / self.fps
                frames_per_chunk = int(self.chunk_duration_sec * self.fps)

                # Setup chunk writer only when recording
                tmp_path = None
                writer = None
                if self._recording:
                    tmp = tempfile.NamedTemporaryFile(
                        suffix=".mp4", delete=False, prefix="aura_chunk_"
                    )
                    tmp_path = tmp.name
                    tmp.close()
                    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
                    writer = cv2.VideoWriter(tmp_path, fourcc, self.fps, (out_w, out_h))

                frame_count = 0
                next_capture = time.monotonic()

                while self._running and frame_count < frames_per_chunk:
                    next_capture += frame_interval

                    raw = sct.grab(monitor)
                    img = np.array(raw)
                    img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

                    h, w = img.shape[:2]
                    if (w, h) != (out_w, out_h):
                        img = cv2.resize(img, (out_w, out_h), interpolation=cv2.INTER_AREA)

                    if self._recording and writer:
                        writer.write(img)

                    frame_count += 1

                    # Measure actual FPS
                    now = time.monotonic()
                    if self._last_frame_time > 0:
                        dt = now - self._last_frame_time
                        if dt > 0:
                            self._actual_fps = 1.0 / dt
                    self._last_frame_time = now

                    with self._frame_lock:
                        self._latest_frame = img.copy()
                        self._frame_seq += 1

                    sleep_time = next_capture - time.monotonic()
                    if sleep_time > 0:
                        time.sleep(sleep_time)
                    else:
                        next_capture = time.monotonic()

                    # In preview-only mode, loop forever (no chunk boundary)
                    if not self._recording:
                        frame_count = 0

                # Finish chunk
                if writer:
                    writer.release()
                if tmp_path and self._recording and self._on_chunk_ready:
                    try:
                        with open(tmp_path, "rb") as f:
                            chunk_bytes = f.read()
                        self._on_chunk_ready(chunk_bytes, self._chunk_index)
                    except Exception as e:
                        print(f"[ScreenCapture] Error reading chunk: {e}")
                if tmp_path:
                    try:
                        os.unlink(tmp_path)
                    except OSError:
                        pass

                with self._lock:
                    self._chunk_index += 1

    # ΓöÇΓöÇ Accessors ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ

    def get_latest_frame(self) -> Optional[np.ndarray]:
        """Get the most recent captured frame (BGR) for UI preview."""
        with self._frame_lock:
            return self._latest_frame.copy() if self._latest_frame is not None else None

    @property
    def frame_seq(self) -> int:
        """Monotonically increasing frame counter."""
        return self._frame_seq

    def get_monitors(self) -> list:
        """Return list of available monitors for selection UI."""
        with mss.mss() as sct:
            return [
                {
                    "index": i,
                    "width": m["width"],
                    "height": m["height"],
                    "left": m["left"],
                    "top": m["top"],
                    "label": f"Monitor {i}: {m['width']}x{m['height']}"
                    if i > 0
                    else "All Monitors Combined",
                }
                for i, m in enumerate(sct.monitors)
            ]
